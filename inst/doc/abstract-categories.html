<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>AbstractCategories</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p><a href="crunch-internals.html">Previous: Crunch internals</a></p>

<p>There are number of areas where Crunch needs to represent an object as belonging to one of many categories. The simplest and most common example of this is the categories of a categorical variable. For a categorical variable, the values of the variable can be one of a limited set of categories and those categories are specified in the Crunch API as metadata about the variable. These categoricals are similar to R&#39;s <code>factor</code>s but are richer because Crunch categoricals can have any number of missing values (compared to just <code>NA</code> for <code>factor</code>s), as well as a numeric representation that is separate from the category ids (which is useful for things like income bins, where you might put the middle of the bin as the value).</p>

<p>Moving beyond just categorical variables, we have a need to be able to represent a number of different properties, transformations, etc. in a category-like way. One concrete example is used heavily in order to add subtotals and headings to representations of categorical variables. In order to do this, we have two families of <a href="http://adv-r.had.co.nz/S4.html">S4 classes</a>: <code>AbstractCategory</code> and <code>AbstractCategories</code> Although subtotals and headings was the initial motivation for the new classes, they will allow for other types of representations and manipulations in the future.</p>

<h2>AbstractCategories</h2>

<p>The core classes that all other classes inherit from are <code>AbstractCategory</code> and <code>AbstractCategories</code>. The first, <code>AbstractCategory</code>, is designed to represent a single category, which might have a number of properties about it (what those are will be explained in more detail below). The second, <code>AbstractCategories</code> is designed to hold more than one <code>AbstractCategory</code> together to form a coherent group. As a simple, example: an <code>AbstractCategories</code> for binned income could have 5 <code>AbstractCategory</code>s: &lt;$25,000, $25,000-$49,999, $50,000-$99,999, $100,000-$199,999, &gt;$200,000. This could be represented in R as:</p>

<pre><code class="r">income &lt;- AbstractCategories(AbstractCategory(name = &quot;&lt;$25,000&quot;),
                             AbstractCategory(name = &quot;$25,000-$49,999&quot;),
                             AbstractCategory(name = &quot;$50,000-$99,999&quot;),
                             AbstractCategory(name = &quot;$100,000-$199,999&quot;),
                             AbstractCategory(name = &quot;&gt;$200,000&quot;))
</code></pre>

<p>An alternate (and less typing) way to instantiate this same <code>AbstractCategories</code> is to send lists, and the constructor takes care of calling the <code>AbstractCategory</code> class on each (as below). Each of the child-classes of <code>AbstractCategories</code> (described in the sections below) have their own mapping of plural container to singular entity constructor in the same way, so passing <code>Categories</code> a list will result in a <code>Categories</code> object full of <code>Category</code> objects.</p>

<pre><code class="r">income &lt;- AbstractCategories(list(name = &quot;&lt;$25,000&quot;),
                             list(name = &quot;$25,000-$49,999&quot;),
                             list(name = &quot;$50,000-$99,999&quot;),
                             list(name = &quot;$100,000-$199,999&quot;),
                             list(name = &quot;&gt;$200,000&quot;))
</code></pre>

<p>Finally, there&#39;s a <code>data</code> argument, if you already have a list of <code>AbstractCategory</code>s (or simply named lists!) you want to pass in (the same thing could also be accomplished with <code>do.call</code>): </p>

<pre><code class="r">income_list &lt;- list(list(name = &quot;&lt;$25,000&quot;),
                    list(name = &quot;$25,000-$49,999&quot;),
                    list(name = &quot;$50,000-$99,999&quot;),
                    list(name = &quot;$100,000-$199,999&quot;),
                    list(name = &quot;&gt;$200,000&quot;))
income &lt;- AbstractCategories(data=income_list)
</code></pre>

<h3>Methods</h3>

<p>Any methods that are defined for the abstract classes will function on the subclasses as well. Child classes might have special over-ride methods defined for them, but for the most part, if a method can be used on <code>AbstractCategories</code> or <code>AbstractCategory</code> it can be used on the child classes as well.</p>

<p><code>AbstractCategories</code> inherits from <code>list</code> and <code>AbstractCategory</code> inherits from <code>namedList</code> so many of the same methods will be work with both of them. This includes using <code>[</code>, <code>[[</code>, <code>[&lt;-</code>, and <code>[[&lt;-</code> to get and set subsets of <code>AbstractCategories</code> and <code>$</code>, and <code>[[</code> to get the properties in an <code>AbstractCategory</code>. </p>

<p><code>lapply</code> has also been defined for <code>AbstractCategories</code> for easily iterating over all members. <code>modifyCats</code> also allows for modifying one <code>AbstractCategories</code> object by updating with new information from a second <code>AbstractCategories</code> object in the same way that <code>modifyList</code> works, but crucially it does not recurse into the <code>AbstractCategory</code> objects themselves. </p>

<p>Finally, there are a few custom methods that return the values of the properties as either a vector of that property for each member (when using the plural versions against <code>AbstractCategories</code>) or a vector (typically of length one) for a single member (when using the singular versions against <code>AbstractCategory</code>). </p>

<p><code>names</code> returns the names associated with each <code>AbstractCategory</code> in an <code>AbstractCategories</code> object. And <code>name</code> returns the names associated with an <code>AbstractCategory</code> object. <code>ids</code> and <code>id</code> patterns the exact same way.</p>

<h2>Categories</h2>

<p>Categories from a categorical variable are represented by the <code>Categories</code> and <code>Category</code> classes. They inherit directly from <code>AbstractCategories</code> and <code>Category</code> respectively. For these, each <code>Category</code> must have a <code>name</code> and an <code>id</code>, they optionally can have a <code>numeric_value</code>, <code>missing</code>, and <code>selected</code> property. </p>

<h3>Methods</h3>

<ul>
<li><code>values</code> and <code>value</code> return the <code>numeric_value</code>s property from <code>Categories</code> or a single <code>Category</code> respectively.</li>
<li><code>is.na</code> and <code>is.na</code> returns the <code>missing</code> property from <code>Categories</code> or a single <code>Category</code> respectively.</li>
<li><code>is.selected</code> and <code>is.selected</code> returns the <code>selected</code> property from <code>Categories</code> or a single <code>Category</code> respectively.</li>
</ul>

<h2>Insertions</h2>

<p>Insertions allow users to insert new categories into a variable or a CrunchCube for display purposes. This is useful when the user would like to show things like aggregates (e.g. subtotals) without manipulating the underlying data (or creating a new variable). Insertions are defined as part of the Crunch API (see the Transforms section below for an explanation about where Insertions live). The <code>Insertion</code>s class is designed to mirror the Crunch API for insertions as closely as possible. <code>Insertions</code> and <code>Insertion</code> inherit directly from <code>AbstractCategories</code> and <code>Category</code> respectively.</p>

<p><code>Insertion</code>s must have a <code>name</code> and an <code>anchor</code>. The <code>name</code> is just like <code>Category</code> names, and is used as the label to display. The <code>anchor</code> is the id of the category after which the insertion should be placed.</p>

<p>Since insertions can represent a number of different aggregations, they also can have <code>function</code> and <code>args</code> properties. The <code>function</code> property is a character describing the aggregation to use (e.g. <code>&quot;subtotal&quot;</code>) and the <code>args</code> property is a vector of the category <code>id</code>s to use as operands for the <code>function</code>.</p>

<p>The <code>Insertion</code> class has two child classes: <code>Subtotal</code> and <code>Heading</code>. The <code>Insertions</code> class can contain anything that inherits from <code>Insertion</code>. Therefor an <code>Insertions</code> object might include <code>Insertion</code>s, <code>Subtotal</code>s, and <code>Heading</code>s.</p>

<h3>Methods</h3>

<ul>
<li><code>anchors</code> and <code>anchor</code> return the anchor property from <code>Insertions</code> or a single <code>Insertion</code> respectively.</li>
<li><code>funcs</code> and <code>func</code> return the function property from <code>Insertions</code> or a single <code>Insertion</code> respectively.</li>
<li><code>arguments</code> returns the <code>args</code> property from a single <code>Insertion</code>.</li>
</ul>

<h2>Subtotals and Headings</h2>

<p>Subtotals and headings are both <em>types</em> of insertions. Because of this <code>Subtotal</code> and <code>Heading</code> classes inherit from <code>Insertion</code> rather than directly from <code>AbstractCategory</code>. These classes are designed to hold known types of Insertions to make it easier to work with Insertions (for example: testing which insertion to style in what way when using <code>prettyPrint</code> functions). Additionally, these classes have slightly more user-friendly names (e.g. <code>after</code> instead of <code>anchor</code>), and they accept either <code>id</code>s or <code>name</code>s to refer to specific <code>Category</code>s.</p>

<h3>Subtotal</h3>

<p>A <code>Subtotal</code> must have <code>name</code>, <code>after</code>, and <code>categories</code> properties. <code>name</code> is the same as other abstract categories. <code>after</code> is similar to <code>anchor</code> but can be either a category <code>id</code> or a category <code>name</code> after which the subtotal should be placed. <code>categories</code> is either the category <code>id</code>s or a category <code>name</code>s to subtotal.</p>

<h4>Methods</h4>

<p>The same as <code>Insertion</code>, however some have customizations: </p>

<ul>
<li><code>func</code> always returns the string <code>&quot;subtotal&quot;</code> (because by definition a <code>Subtotal</code> object is an <code>Insertion</code> with <code>function=&quot;subtotal&quot;</code>)</li>
<li><code>anchor</code> and <code>arguments</code> both have an option <code>var_categories</code> which is required if the <code>Subtotal</code> is using category names instead of ids in the <code>after</code> or <code>categories</code> properties. Supplying the categories is required in order to translate from category <code>name</code>s to <code>id</code>s which are required to be a well-formed <code>Insertion</code>.</li>
</ul>

<h3>Heading</h3>

<p>A <code>Heading</code> must have <code>name</code> and <code>after</code> properties. Both of which have the same interpretation as <code>Subtotal</code> above.</p>

<h4>Methods</h4>

<p>The same as <code>Subtotal</code> for <code>anchor</code>. <code>func</code> and <code>arguments</code> return <code>NA</code></p>

<p>As a concrete example, let&#39;s take the following categories:</p>

<pre><code class="r">feeling_cats &lt;- Categories(
    list(name = &quot;Very Happy&quot;, id = 1),
    list(name = &quot;Somewhat Happy&quot;, id = 2),
    list(name = &quot;Neither Happy nor Unhappy&quot;, id = 3),
    list(name = &quot;Somewhat Unhappy&quot;, id = 4),
    list(name = &quot;Very Unhappy&quot;, id = 5)
)
feeling_cats
</code></pre>

<pre><code>##   id                      name value missing
## 1  1                Very Happy    NA   FALSE
## 2  2            Somewhat Happy    NA   FALSE
## 3  3 Neither Happy nor Unhappy    NA   FALSE
## 4  4          Somewhat Unhappy    NA   FALSE
## 5  5              Very Unhappy    NA   FALSE
</code></pre>

<p>And make some subtotals and headings to use as insertions:</p>

<pre><code class="r">feeling_subtotals &lt;- Insertions(
    Heading(name = &quot;How I feel about cheese&quot;, position = &quot;top&quot;),
    Subtotal(name = &quot;Generally Happy&quot;, after = &quot;Somewhat Happy&quot;, 
        categories = c(&quot;Very Happy&quot;, &quot;Somewhat Happy&quot;)),
    Subtotal(name = &quot;Generally Unhappy&quot;, after = 5, 
        categories = c(4, 5))
)
</code></pre>

<p>Notice that the &ldquo;Generally Happy&rdquo; subtotal is made specifying category <code>name</code>s for <code>after</code> and <code>categories</code>:</p>

<pre><code class="r">feeling_subtotals[[2]]$after
</code></pre>

<pre><code>## [1] &quot;Somewhat Happy&quot;
</code></pre>

<pre><code class="r">feeling_subtotals[[2]]$categories
</code></pre>

<pre><code>## [1] &quot;Very Happy&quot;     &quot;Somewhat Happy&quot;
</code></pre>

<p>Where as the &ldquo;Generally Unhappy&rdquo; subtotal uses <code>id</code>s:</p>

<pre><code class="r">feeling_subtotals[[3]]$after
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">feeling_subtotals[[3]]$categories
</code></pre>

<pre><code>## [1] 4 5
</code></pre>

<h3>Converting from Subtotal/Heading to Insertion</h3>

<p>Since the Crunch API does not have a distinction between <code>Subtotal</code>s <code>Heading</code>s, and other <code>Insertion</code>s, we sometimes need to convert from <code>Subtotal</code>s or <code>Heading</code>s to <code>Insertion</code>s. This is accomplished with the method <code>makeInsertion()</code>. This method takes a <code>Subtotal</code> or <code>Heading</code> and returns a valid <code>Insertion</code>. If the <code>Subtotal</code> or <code>Heading</code> has category <code>name</code> references instead of <code>id</code>s, then you must include a <code>Categories</code> object as the <code>var_categories</code> argument. In general, this is only needed before sending a heterogeneous set of <code>Insertions</code> to the Crunch API.</p>

<p>Using the examples we used before, we can see how this works:</p>

<pre><code class="r">feeling_insertions &lt;- Insertions(data = lapply(feeling_subtotals, makeInsertion, var_categories = feeling_cats))
</code></pre>

<p>Now, all of the <code>Subtotal</code>s and <code>Heading</code> from <code>feeling_subtotals</code> are proper <code>Insertion</code>s:</p>

<pre><code class="r">sapply(feeling_insertions, class)
</code></pre>

<pre><code>## [1] &quot;Insertion&quot; &quot;Insertion&quot; &quot;Insertion&quot;
</code></pre>

<p>This means that the <code>after</code> property has been translated into <code>anchor</code>, and the <code>function</code> and <code>args</code> properties have been filled in appropriately:</p>

<pre><code class="r">feeling_insertions[[3]]$anchor
</code></pre>

<pre><code>## [1] 5
</code></pre>

<pre><code class="r">feeling_insertions[[3]]$`function`
</code></pre>

<pre><code>## [1] &quot;subtotal&quot;
</code></pre>

<pre><code class="r">feeling_insertions[[3]]$args
</code></pre>

<pre><code>## [1] 4 5
</code></pre>

<p>Because <code>Insertion</code>s are required to use category <code>id</code>s only, the new all-<code>Insertion</code>s <code>feeling_insertions</code> has translated the &ldquo;Generally Happy&rdquo; subtotal&#39;s category <code>name</code>s to <code>id</code>s:</p>

<pre><code class="r">feeling_insertions[[2]]$anchor
</code></pre>

<pre><code>## [1] 2
</code></pre>

<pre><code class="r">feeling_insertions[[2]]$args
</code></pre>

<pre><code>## [1] 1 2
</code></pre>

<h3>Converting from Insertion to Subtotal/Heading</h3>

<p>Since the Crunch API does not have a distinction between <code>Subtotal</code>s <code>Heading</code>s, and other <code>Insertion</code>s when we get data about <code>Insertion</code>s from the API, we need to change the classes for the <code>Insertion</code>s that the <code>crunch</code> package knows about. To do this, we can use either <code>subtypeInsertions</code> to change the types of all of the members of an <code>Insertions</code> object, or <code>subtypeInsertion</code> to change the type of a single <code>Insertion</code> object.</p>

<p>These functions work by inspecting the <code>Insertion</code> and determining if it can be identified as one of the known child classes of <code>Insertion</code> (namely: <code>Subtotal</code> or <code>Heading</code>).</p>

<p>Using the same example above, we can convert back from all <code>Insertion</code>s to the subtypes:</p>

<pre><code class="r">feeling_subtotals_again &lt;- subtypeInsertions(feeling_insertions)
sapply(feeling_subtotals_again, class)
</code></pre>

<pre><code>## [1] &quot;Heading&quot;  &quot;Subtotal&quot; &quot;Subtotal&quot;
</code></pre>

<h2>Inheritance</h2>

<p>There are two sets of inheritance: one for containers and one for members: Classes inherit from those immediately to their left</p>

<table><thead>
<tr>
<th></th>
<th>top-level classes</th>
<th>1st children</th>
<th>2nd children</th>
</tr>
</thead><tbody>
<tr>
<td>containers</td>
<td><code>AnstractCategories</code></td>
<td><code>Categories</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>AnstractCategories</code></td>
<td><code>Insertions</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>members</td>
<td><code>AbstractCategory</code></td>
<td><code>Category</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>AbstractCategory</code></td>
<td><code>Insertion</code></td>
<td><code>Subtotal</code></td>
</tr>
<tr>
<td></td>
<td><code>AbstractCategory</code></td>
<td><code>Insertion</code></td>
<td><code>Heading</code></td>
</tr>
</tbody></table>

<h2>Shared methods chart</h2>

<p>The methods are listed as row labels and the classes are column labels. If a method is implemented, it is marked &ldquo;impl.&rdquo;.</p>

<h3>Containers</h3>

<table><thead>
<tr>
<th></th>
<th>AbstractCategories</th>
<th>Categories</th>
<th>Insertions</th>
</tr>
</thead><tbody>
<tr>
<td><code>names</code></td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
</tr>
<tr>
<td><code>ids</code></td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
</tr>
<tr>
<td><code>values</code></td>
<td></td>
<td>impl.</td>
<td></td>
</tr>
<tr>
<td><code>is.na</code></td>
<td></td>
<td>impl.</td>
<td></td>
</tr>
<tr>
<td><code>is.selected</code></td>
<td></td>
<td>impl.</td>
<td></td>
</tr>
<tr>
<td><code>anchors</code></td>
<td></td>
<td></td>
<td>impl.</td>
</tr>
<tr>
<td><code>funcs</code></td>
<td></td>
<td></td>
<td>impl.</td>
</tr>
</tbody></table>

<h3>Members</h3>

<table><thead>
<tr>
<th></th>
<th>AbstractCategory</th>
<th>Category</th>
<th>Insertion</th>
<th>Subtotal</th>
<th>Heading</th>
</tr>
</thead><tbody>
<tr>
<td><code>name</code></td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
</tr>
<tr>
<td><code>id</code></td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
</tr>
<tr>
<td><code>value</code></td>
<td></td>
<td>impl.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>is.na</code></td>
<td></td>
<td>impl.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>is.selected</code></td>
<td></td>
<td>impl.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>anchor</code></td>
<td></td>
<td></td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
</tr>
<tr>
<td><code>func</code></td>
<td></td>
<td></td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
</tr>
<tr>
<td><code>arguments</code></td>
<td></td>
<td></td>
<td>impl.</td>
<td>impl.</td>
<td>impl.</td>
</tr>
</tbody></table>

<h2>Transforms</h2>

<p>The <code>Transforms</code> class and set of functions is not an abstract category at all, but rather it mirrors the Crunch API&#39;s set of transformations that are allowed on a variable or CrunchCube. One of the possible transformations are insertions (which is where <code>Insertions</code> are stored). Currently the <code>crunch</code> package doesn&#39;t support other transformations.</p>

</body>

</html>
